# CLAUDE.md — Java 17 Quarkus HTTPS Crypto Demo (Non-PQC)

## Goal (5-minute demo, dead simple)
Build a minimal “enterprise-style” Java 17 Quarkus server that:
- serves **HTTPS** only using a **self-signed certificate**
- exposes:
  - `GET https://localhost:8080/hello`
  - `GET https://localhost:8080/crypto/capabilities`
- uses ONLY standard Java/Quarkus TLS (no custom crypto code, no PQC)
- includes a script `scripts/client-demo.sh` that shows the **actual TLS crypto** used when querying `/hello`

This demo is explicitly about: “What crypto is used today in a typical enterprise Java 17 app, and what key sizes / algorithms are involved.”

---

## Constraints
- Java: 17
- Framework: Quarkus (simple REST)
- TLS: self-signed certificate, local only
- No custom crypto implementation (no ECDH demo, no HKDF, no AES code, etc.)
- Prefer clarity over features: smallest possible source code footprint

---

## Deliverables
1) Quarkus app with HTTPS enabled and self-signed cert
2) Endpoint: `GET /hello` -> `hello world`
3) Endpoint: `GET /crypto/capabilities` -> JSON showing:
   - Java runtime info
   - Security providers
   - TLS capabilities of the runtime (supported + enabled):
     - protocols (TLSv1.2/TLSv1.3 etc.)
     - cipher suites
     - named groups / supported groups if available
   - **Server certificate details** (important!):
     - public key algorithm (RSA/EC)
     - public key size (e.g., RSA 2048, EC 256)
     - signature algorithm (e.g., SHA256withRSA)
     - validity dates
4) Script `scripts/client-demo.sh` that:
   - calls `https://localhost:8080/hello` (with proper trust handling)
   - prints the negotiated TLS details (protocol + cipher suite)
   - prints server certificate key algorithm + key size
   - clearly shows: “this is non-PQC classical TLS”

---

## Repository Layout
.
├─ CLAUDE.md
├─ README.md
├─ pom.xml
├─ src/main/java/.../
│  ├─ HelloResource.java
│  └─ CryptoCapabilitiesResource.java
├─ src/main/resources/
│  └─ application.properties
├─ scripts/
│  └─ client-demo.sh
└─ tls/
   ├─ server-keystore.p12        (generated, can be committed or generated by script)
   └─ server-cert.pem            (exported PEM for client use)

Keep code minimal: 2 resources only.

---

## HTTPS / Self-signed certificate requirements
Use a PKCS12 keystore and configure Quarkus HTTPS.

### Keystore generation (preferred: checked into repo under ./tls)
Generate once (or provide a helper section in README):

- create PKCS12 keystore:
  keytool -genkeypair \
    -alias server \
    -keyalg RSA \
    -keysize 2048 \
    -storetype PKCS12 \
    -keystore tls/server-keystore.p12 \
    -storepass changeit \
    -dname "CN=localhost, OU=Dev, O=Demo, L=Zurich, ST=ZH, C=CH" \
    -validity 3650 \
    -ext "SAN=dns:localhost,ip:127.0.0.1"

- export cert to PEM for curl:
  keytool -exportcert \
    -alias server \
    -keystore tls/server-keystore.p12 \
    -storepass changeit \
    -rfc \
    -file tls/server-cert.pem

NOTE: Use RSA-2048 for maximum “enterprise typical” familiarity. (EC is also ok, but RSA makes key size discussions straightforward.)

### Quarkus HTTPS configuration (application.properties)
- Set HTTPS port to 8080 for the demo
- Disable HTTP (or at least do not bind it)

Required properties:
- quarkus.http.ssl-port=8080
- quarkus.http.insecure-requests=disabled
- quarkus.http.ssl.certificate.key-store-file=tls/server-keystore.p12
- quarkus.http.ssl.certificate.key-store-password=changeit
- quarkus.http.ssl.certificate.key-store-file-type=PKCS12

Optional (keep default if unsure):
- do NOT hardcode cipher suites unless necessary; default is fine for “enterprise default libs”
- if you set protocols, allow TLSv1.3 and TLSv1.2:
  quarkus.http.ssl.protocols=TLSv1.3,TLSv1.2

---

## REST API Spec

### GET /hello
- Response: plain text: "hello world"
- Must be served over HTTPS only:
  https://localhost:8080/hello

### GET /crypto/capabilities
Return JSON with the following structure (fields must exist even if empty):

{
  "runtime": {
    "javaVersion": "...",
    "javaVendor": "...",
    "javaVmName": "...",
    "osName": "...",
    "osArch": "..."
  },
  "securityProviders": [
    { "name": "...", "version": "...", "info": "..." }
  ],
  "tls": {
    "defaultSslContextProvider": "...",
    "supportedProtocols": [ "TLSv1.3", "TLSv1.2", ... ],
    "enabledProtocols": [ ... ],
    "supportedCipherSuites": [ ... ],
    "enabledCipherSuites": [ ... ],
    "namedGroups": {
      "supported": [ ... ],
      "enabled": [ ... ],
      "note": "If named groups cannot be read portably in Java 17, return empty arrays with a note."
    }
  },
  "serverCertificate": {
    "subject": "...",
    "issuer": "...",
    "notBefore": "...",
    "notAfter": "...",
    "publicKeyAlgorithm": "RSA|EC|...",
    "publicKeySizeBits": 2048,
    "signatureAlgorithm": "...",
    "san": [ "DNS:localhost", "IP:127.0.0.1", ... ]
  },
  "pqc": {
    "presentInDefaultProviders": false,
    "note": "Java 17 default providers do not include standardized PQC algorithms (e.g., ML-KEM/ML-DSA)."
  }
}

Implementation notes:
- TLS protocols/ciphers:
  - Use SSLContext.getDefault()
  - Use SSLParameters from SSLSocketFactory / SSLServerSocketFactory to read supported/enabled.
- Named groups:
  - Java’s supported groups can be tricky and provider-dependent.
  - Try reading system properties such as:
    - "jdk.tls.namedGroups" (may be unset)
  - If not reliably available, return empty arrays and a note.
- Server certificate:
  - Load from the same keystore configured for Quarkus:
    - open tls/server-keystore.p12
    - read cert for alias "server"
  - Determine key size:
    - RSA: ((RSAPublicKey) key).getModulus().bitLength()
    - EC: ((ECPublicKey) key).getParams().getCurve().getField().getFieldSize()

Keep the code small and readable.

---

## scripts/client-demo.sh requirements
The script must show what crypto is used when querying:
- https://localhost:8080/hello

It should print, at minimum:
- negotiated protocol (e.g., TLSv1.3)
- negotiated cipher suite (e.g., TLS_AES_128_GCM_SHA256)
- server certificate public key algorithm + size (e.g., RSA 2048)
- server certificate signature algorithm
- and then perform the actual GET /hello successfully.

### Script outline (bash)
1) Verify server is running
2) Show negotiated TLS details using openssl:
   - openssl s_client -connect localhost:8080 -servername localhost -showcerts </dev/null 2>/dev/null
   - parse lines for:
     - "Protocol  :" (or equivalent)
     - "Cipher    :" (or "Ciphersuite:" depending on openssl version)
3) Extract the leaf certificate and show key size:
   - pipe cert to: openssl x509 -noout -text
   - parse:
     - "Public-Key:" size
     - "Signature Algorithm:"
4) Call the endpoint:
   - curl --cacert tls/server-cert.pem https://localhost:8080/hello
   - Must succeed without -k (no insecure skip). Using the exported PEM is the point.

The output must be demo-friendly and short, e.g.:

TLS Negotiation:
  Protocol: TLSv1.3
  Cipher: TLS_AES_128_GCM_SHA256

Server Certificate:
  Public Key: RSA 2048
  Signature: sha256WithRSAEncryption

GET /hello:
  hello world

---

## README.md requirements
Keep README short with:
- prerequisites (Java 17, Maven, openssl, curl, keytool)
- how to generate certs (or state they are included under ./tls)
- how to run:
  - mvn quarkus:dev
  - ./scripts/client-demo.sh
- one “migration hook” section:
  - emphasize key sizes and classical algorithms
  - explain: Java 17 uses classical TLS; PQ requires upgrade/provider/stack changes later

---

## Acceptance Criteria
- `https://localhost:8080/hello` returns "hello world"
- HTTP is disabled (or at least not used in docs/scripts)
- `https://localhost:8080/crypto/capabilities` returns JSON including:
  - supported/enabled protocols and cipher suites
  - **certificate public key size**
- `scripts/client-demo.sh`:
  - prints TLS protocol + cipher suite
  - prints cert key size + signature alg
  - successfully calls /hello using `--cacert tls/server-cert.pem` (no `-k`)
- Source code is minimal and easy to read (2 resources, small helpers if necessary)
