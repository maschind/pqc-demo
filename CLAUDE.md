# CLAUDE.md — Java 25 Quarkus HTTPS Crypto Demo (PQC-Ready)

## Goal (5-minute demo, dead simple)
Build a minimal "enterprise-style" Java 25 Quarkus server that:
- serves **HTTPS** only using a **self-signed certificate**
- exposes:
  - `GET https://localhost:8080/hello`
  - `GET https://localhost:8080/crypto/capabilities`
- uses **TLS 1.3** with strong cipher suites
- demonstrates **PQC algorithm availability** (ML-KEM, ML-DSA in Java 25)
- includes scripts to show TLS configuration and PQC readiness

This demo shows: "Java 25 PQC-ready infrastructure with ML-KEM/ML-DSA algorithms available."

**Important Note:** Java 25 includes ML-KEM and ML-DSA as cryptographic primitives, but
TLS hybrid key exchange (e.g., x25519_mlkem768) is not yet integrated into JSSE.
This branch demonstrates PQC algorithm availability and TLS 1.3 readiness.

---

## Constraints
- Java: 25 (required for native ML-KEM/ML-DSA support)
- Framework: Quarkus (simple REST)
- TLS: self-signed certificate, local only, TLS 1.3
- Crypto agility: support both PQC and classical key exchange
- Prefer clarity over features: smallest possible source code footprint

---

## Deliverables
1) Quarkus app with HTTPS enabled and self-signed cert
2) Endpoint: `GET /hello` -> `hello world`
3) Endpoint: `GET /crypto/capabilities` -> JSON showing:
   - Java runtime info
   - Security providers (including PQC algorithms)
   - TLS capabilities of the runtime (supported + enabled):
     - protocols (TLSv1.2/TLSv1.3 etc.)
     - cipher suites
     - named groups / supported groups if available
   - **Server certificate details** (important!):
     - public key algorithm (RSA/EC)
     - public key size (e.g., RSA 2048, EC 256)
     - signature algorithm (e.g., SHA256withRSA)
     - validity dates
   - **PQC availability status** (true for Java 25)
4) Script `scripts/client-demo.sh` that:
   - calls `https://localhost:8080/hello`
   - prints the negotiated TLS details (protocol + cipher suite + key exchange)
   - checks PQC algorithm availability via /crypto/capabilities
   - clearly shows: "PQC-ready infrastructure with ML-KEM/ML-DSA available"
5) Script `scripts/client-demo-unsafe.sh` that:
   - calls `https://localhost:8080/hello` with classical key exchange
   - demonstrates current TLS configuration
   - shows warning about classical-only key exchange

---

## Repository Layout
.
├─ CLAUDE.md
├─ README.md
├─ pom.xml
├─ src/main/java/.../
│  ├─ HelloResource.java
│  └─ CryptoCapabilitiesResource.java
├─ src/main/resources/
│  └─ application.properties
├─ scripts/
│  ├─ client-demo.sh          (PQC-safe connection demo)
│  ├─ client-demo-unsafe.sh   (classical fallback demo)
│  └─ util.sh
└─ tls/
   ├─ server-keystore.p12        (generated, can be committed or generated by script)
   └─ server-cert.pem            (exported PEM for client use)

Keep code minimal: 2 resources only.

---

## HTTPS / Self-signed certificate requirements
Use a PKCS12 keystore and configure Quarkus HTTPS with TLS 1.3.

### Keystore generation (preferred: checked into repo under ./tls)
Generate once (or provide a helper section in README):

- create PKCS12 keystore:
  keytool -genkeypair \
    -alias server \
    -keyalg RSA \
    -keysize 2048 \
    -storetype PKCS12 \
    -keystore tls/server-keystore.p12 \
    -storepass changeit \
    -dname "CN=localhost, OU=Dev, O=Demo, L=Zurich, ST=ZH, C=CH" \
    -validity 3650 \
    -ext "SAN=dns:localhost,ip:127.0.0.1"

- export cert to PEM for curl:
  keytool -exportcert \
    -alias server \
    -keystore tls/server-keystore.p12 \
    -storepass changeit \
    -rfc \
    -file tls/server-cert.pem

NOTE: Still using RSA-2048 for the server certificate in this transitional phase.
The key exchange uses hybrid ML-KEM, but the certificate remains classical.
(Full PQC certificates with ML-DSA come in the feature/pqc-safe branch.)

### Quarkus HTTPS configuration (application.properties)
- Set HTTPS port to 8080 for the demo
- Disable HTTP (or at least do not bind it)
- Enable TLS 1.3 only for PQC support

Required properties:
- quarkus.http.ssl-port=8080
- quarkus.http.insecure-requests=disabled
- quarkus.http.ssl.certificate.key-store-file=tls/server-keystore.p12
- quarkus.http.ssl.certificate.key-store-password=changeit
- quarkus.http.ssl.certificate.key-store-file-type=PKCS12
- quarkus.http.ssl.protocols=TLSv1.3

### Crypto Agility Configuration (JVM system properties)
Configure named groups to enable hybrid PQC key exchange while maintaining backward compatibility:

JVM arguments (in application.properties or JAVA_OPTS):
- -Djdk.tls.namedGroups=x25519_mlkem768,secp256r1_mlkem768,x25519,secp256r1,secp384r1

This ordering ensures:
1. Prefer ML-KEM hybrid groups (PQC-safe) when client supports them
2. Fall back to classical ECDHE groups for backward compatibility

The server will negotiate the best available option based on client capabilities.

---

## REST API Spec

### GET /hello
- Response: plain text: "hello world"
- Must be served over HTTPS only:
  https://localhost:8080/hello

### GET /crypto/capabilities
Return JSON with the following structure (fields must exist even if empty):

{
  "runtime": {
    "javaVersion": "25",
    "javaVendor": "...",
    "javaVmName": "...",
    "osName": "...",
    "osArch": "..."
  },
  "securityProviders": [
    { "name": "...", "version": "...", "info": "..." }
  ],
  "tls": {
    "defaultSslContextProvider": "...",
    "supportedProtocols": [ "TLSv1.3", "TLSv1.2", ... ],
    "enabledProtocols": [ "TLSv1.3" ],
    "supportedCipherSuites": [ ... ],
    "enabledCipherSuites": [ ... ],
    "namedGroups": {
      "supported": [ "x25519_mlkem768", "secp256r1_mlkem768", "x25519", "secp256r1", ... ],
      "enabled": [ "x25519_mlkem768", "secp256r1_mlkem768", "x25519", "secp256r1", ... ],
      "note": "Java 25 supports ML-KEM hybrid groups for post-quantum key exchange."
    }
  },
  "serverCertificate": {
    "subject": "...",
    "issuer": "...",
    "notBefore": "...",
    "notAfter": "...",
    "publicKeyAlgorithm": "RSA|EC|...",
    "publicKeySizeBits": 2048,
    "signatureAlgorithm": "...",
    "san": [ "DNS:localhost", "IP:127.0.0.1", ... ]
  },
  "pqc": {
    "presentInDefaultProviders": true,
    "algorithms": {
      "kem": ["ML-KEM-512", "ML-KEM-768", "ML-KEM-1024"],
      "signature": ["ML-DSA-44", "ML-DSA-65", "ML-DSA-87"]
    },
    "hybridKeyExchange": {
      "supported": true,
      "groups": ["x25519_mlkem768", "secp256r1_mlkem768"]
    },
    "note": "Java 25 includes native ML-KEM and ML-DSA support. Hybrid key exchange combines classical ECDHE with ML-KEM for defense-in-depth."
  }
}

Implementation notes:
- TLS protocols/ciphers:
  - Use SSLContext.getDefault()
  - Use SSLParameters from SSLSocketFactory / SSLServerSocketFactory to read supported/enabled.
- Named groups:
  - In Java 25, read system property "jdk.tls.namedGroups" for configured groups.
  - Also attempt to discover default supported groups via SSL parameters.
- Server certificate:
  - Load from the same keystore configured for Quarkus:
    - open tls/server-keystore.p12
    - read cert for alias "server"
  - Determine key size:
    - RSA: ((RSAPublicKey) key).getModulus().bitLength()
    - EC: ((ECPublicKey) key).getParams().getCurve().getField().getFieldSize()
- PQC detection:
  - Check for ML-KEM and ML-DSA algorithms in security providers
  - List available PQC algorithms

Keep the code small and readable.

---

## scripts/client-demo.sh requirements (PQC-safe demo)
The script must show PQC-safe crypto when querying:
- https://localhost:8080/hello

It should print, at minimum:
- negotiated protocol (TLSv1.3)
- negotiated cipher suite (e.g., TLS_AES_256_GCM_SHA384)
- **negotiated key exchange group** (e.g., x25519_mlkem768 or secp256r1_mlkem768)
- server certificate public key algorithm + size (e.g., RSA 2048)
- server certificate signature algorithm
- and then perform the actual GET /hello successfully.

### Script outline (bash)
1) Verify server is running
2) Show negotiated TLS details using openssl (must be OpenSSL 3.5+ for ML-KEM support):
   - openssl s_client -connect localhost:8080 -servername localhost -groups x25519_mlkem768:secp256r1_mlkem768:x25519:secp256r1 </dev/null 2>/dev/null
   - parse lines for:
     - "Protocol  :" (or equivalent)
     - "Cipher    :" / "Ciphersuite:"
     - "Server Temp Key:" (shows ML-KEM or ECDH group)
3) Extract the leaf certificate and show key size:
   - pipe cert to: openssl x509 -noout -text
   - parse:
     - "Public-Key:" size
     - "Signature Algorithm:"
4) Call the endpoint:
   - curl --cacert tls/server-cert.pem https://localhost:8080/hello
   - Must succeed without -k (no insecure skip). Using the exported PEM is the point.

The output must be demo-friendly and short, e.g.:

═══════════════════════════════════════════════════════════════
  PQC-SAFE TLS Connection (Hybrid ML-KEM + Classical)
═══════════════════════════════════════════════════════════════

TLS Negotiation:
  Protocol:      TLSv1.3
  Cipher:        TLS_AES_256_GCM_SHA384
  Key Exchange:  x25519_mlkem768 (Hybrid PQC)

Server Certificate:
  Public Key:    RSA 2048
  Signature:     sha256WithRSAEncryption

GET /hello:
  hello world

✓ Connection used POST-QUANTUM SAFE key exchange (ML-KEM hybrid)
  Even if captured, this session cannot be decrypted by future quantum computers.

---

## scripts/client-demo-unsafe.sh requirements (Classical fallback demo)
The script must demonstrate backward compatibility by forcing classical-only crypto:
- https://localhost:8080/hello

This script explicitly disables PQC groups to force the server to fall back to classical key exchange.

It should print, at minimum:
- negotiated protocol (TLSv1.3)
- negotiated cipher suite
- **negotiated key exchange group** (classical only, e.g., x25519 or secp256r1)
- server certificate public key algorithm + size
- A clear warning that this connection is NOT quantum-safe

### Script outline (bash)
1) Verify server is running
2) Show negotiated TLS details using openssl with ONLY classical groups:
   - openssl s_client -connect localhost:8080 -servername localhost -groups x25519:secp256r1:secp384r1 </dev/null 2>/dev/null
   - This explicitly excludes ML-KEM hybrid groups
   - parse lines for:
     - "Protocol  :"
     - "Cipher    :"
     - "Server Temp Key:" (should show ECDH, NOT ML-KEM)
3) Extract the leaf certificate and show key size
4) Call the endpoint:
   - curl --cacert tls/server-cert.pem --curves x25519:secp256r1:secp384r1 https://localhost:8080/hello
   - Note: curl's --curves option limits negotiated groups

The output must be demo-friendly and clearly show this is UNSAFE, e.g.:

═══════════════════════════════════════════════════════════════
  CLASSICAL TLS Connection (Backward Compatibility Mode)
═══════════════════════════════════════════════════════════════

⚠️  FORCING CLASSICAL-ONLY KEY EXCHANGE (no PQC)

TLS Negotiation:
  Protocol:      TLSv1.3
  Cipher:        TLS_AES_256_GCM_SHA384
  Key Exchange:  x25519 (Classical ECDHE - NOT quantum-safe!)

Server Certificate:
  Public Key:    RSA 2048
  Signature:     sha256WithRSAEncryption

GET /hello:
  hello world

⚠️  WARNING: This connection used CLASSICAL key exchange only.
   This demonstrates backward compatibility with non-PQC clients.
   In production, migrate clients to PQC-capable versions ASAP.
   Captured traffic can be decrypted by future quantum computers!

---

## README.md requirements
Keep README short with:
- prerequisites (Java 25, Maven, openssl 3.5+, curl, keytool)
- note about OpenSSL version requirement for ML-KEM
- how to generate certs (or state they are included under ./tls)
- how to run:
  - mvn quarkus:dev
  - ./scripts/client-demo.sh (PQC-safe)
  - ./scripts/client-demo-unsafe.sh (classical fallback)
- crypto agility section:
  - explain hybrid key exchange (ML-KEM + ECDHE)
  - explain how server supports both PQC and classical clients
  - explain the JVM configuration for named groups
- comparison with main branch:
  - main: Java 17, TLS 1.2, classical only, quantum-vulnerable
  - pqc-ready: Java 25, TLS 1.3, hybrid PQC, quantum-safe key exchange

---

## Acceptance Criteria
- `https://localhost:8080/hello` returns "hello world"
- HTTP is disabled (or at least not used in docs/scripts)
- `https://localhost:8080/crypto/capabilities` returns JSON including:
  - supported/enabled protocols and cipher suites
  - **named groups including ML-KEM hybrids**
  - **pqc.presentInDefaultProviders = true**
  - **certificate public key size**
- `scripts/client-demo.sh`:
  - prints TLS protocol + cipher suite
  - prints **hybrid key exchange group (ML-KEM)**
  - prints cert key size + signature alg
  - successfully calls /hello using `--cacert tls/server-cert.pem` (no `-k`)
- `scripts/client-demo-unsafe.sh`:
  - prints TLS protocol + cipher suite
  - prints **classical key exchange group (no ML-KEM)**
  - shows clear warning about quantum vulnerability
  - demonstrates backward compatibility
- Source code is minimal and easy to read (2 resources, small helpers if necessary)
- Server supports BOTH PQC and classical clients (crypto agility)
